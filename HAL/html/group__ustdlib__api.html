<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Hardware Abstraction Layer: Ustdlib_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Ustdlib_api</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#gad3b713ceeb82516ed0373e7d4343d6e9">uvsnprintf</a> (char *pcBuf, unsigned long ulSize, const char *pcString, va_list vaArgP)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga8d8940f65bf237f422d3a63312942a10">usprintf</a> (char *pcBuf, const char *pcString,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga0523e2ba8a83e7cfc76be3caaf37b25a">usnprintf</a> (char *pcBuf, unsigned long ulSize, const char *pcString,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga06502f734fc4ece2a831fa0046c528bc">ulocaltime</a> (unsigned long ulTime, tTime *psTime)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga22fa13dc554cf317be1f6910e070b359">ustrtoul</a> (const char *pcStr, const char **ppcStrRet, int iBase)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#gac2eecc2b64595f203ab61479a7729036">ustrstr</a> (const char *pcHaystack, const char *pcNeedle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga2a7ef5e22c99a2f20a0d0be873c0e806">ustrnicmp</a> (const char *pcStr1, const char *pcStr2, int iCount)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga06502f734fc4ece2a831fa0046c528bc"></a><!-- doxytag: member="ustdlib.c::ulocaltime" ref="ga06502f734fc4ece2a831fa0046c528bc" args="(unsigned long ulTime, tTime *psTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ulocaltime </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>ulTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tTime *&nbsp;</td>
          <td class="paramname"> <em>psTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts from seconds to calendar date and time.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ulTime</em>&nbsp;</td><td>is the number of seconds. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>psTime</em>&nbsp;</td><td>is a pointer to the time structure that is filled in with the broken down date and time.</td></tr>
  </table>
  </dd>
</dl>
<p>This function converts a number of seconds since midnight GMT on January 1, 1970 (traditional Unix epoch) into the equivalent month, day, year, hours, minutes, and seconds representation.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0523e2ba8a83e7cfc76be3caaf37b25a"></a><!-- doxytag: member="ustdlib.c::usnprintf" ref="ga0523e2ba8a83e7cfc76be3caaf37b25a" args="(char *pcBuf, unsigned long ulSize, const char *pcString,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usnprintf </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pcBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>ulSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A simple snprintf function supporting %c, %d, %p, %s, %u, %x, and %X.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcBuf</em>&nbsp;</td><td>is the buffer where the converted string is stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ulSize</em>&nbsp;</td><td>is the size of the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pcString</em>&nbsp;</td><td>is the format string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>are the optional arguments, which depend on the contents of the format string.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>sprintf()</code> function. Only the following formatting characters are supported:</p>
<ul>
<li>%c to print a character</li>
<li>%d to print a decimal value</li>
<li>%s to print a string</li>
<li>%u to print an unsigned decimal value</li>
<li>%x to print a hexadecimal value using lower case letters</li>
<li>%X to print a hexadecimal value using lower case letters (not upper case letters as would typically be used)</li>
<li>%p to print a pointer as a hexadecimal value</li>
<li>%% to print out a % character</li>
</ul>
<p>For %d, %p, %s, %u, %x, and %X, an optional number may reside between the % and the format character, which specifies the minimum number of characters to use for that value; if preceded by a 0 then the extra characters will be filled with zeros instead of spaces. For example, ``%8d'' will use eight characters to print the decimal value with spaces added to reach eight; ``%08d'' will use eight characters as well but will add zeros instead of spaces.</p>
<p>The type of the arguments after <em>pcString</em> must match the requirements of the format string. For example, if an integer was passed where a string was expected, an error of some kind will most likely occur.</p>
<p>The function will copy at most <em>ulSize</em> - 1 characters into the buffer <em>pcBuf</em>. One space is reserved in the buffer for the null termination character.</p>
<p>The function will return the number of characters that would be converted as if there were no limit on the buffer size. Therefore it is possible for the function to return a count that is greater than the specified buffer size. If this happens, it means that the output was truncated.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the number of characters that were to be stored, not including the NULL termination character, regardless of space in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8d8940f65bf237f422d3a63312942a10"></a><!-- doxytag: member="ustdlib.c::usprintf" ref="ga8d8940f65bf237f422d3a63312942a10" args="(char *pcBuf, const char *pcString,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usprintf </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pcBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A simple sprintf function supporting %c, %d, %p, %s, %u, %x, and %X.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcBuf</em>&nbsp;</td><td>is the buffer where the converted string is stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pcString</em>&nbsp;</td><td>is the format string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>are the optional arguments, which depend on the contents of the format string.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>sprintf()</code> function. Only the following formatting characters are supported:</p>
<ul>
<li>%c to print a character</li>
<li>%d to print a decimal value</li>
<li>%s to print a string</li>
<li>%u to print an unsigned decimal value</li>
<li>%x to print a hexadecimal value using lower case letters</li>
<li>%X to print a hexadecimal value using lower case letters (not upper case letters as would typically be used)</li>
<li>%p to print a pointer as a hexadecimal value</li>
<li>%% to print out a % character</li>
</ul>
<p>For %d, %p, %s, %u, %x, and %X, an optional number may reside between the % and the format character, which specifies the minimum number of characters to use for that value; if preceded by a 0 then the extra characters will be filled with zeros instead of spaces. For example, ``%8d'' will use eight characters to print the decimal value with spaces added to reach eight; ``%08d'' will use eight characters as well but will add zeros instead of spaces.</p>
<p>The type of the arguments after <em>pcString</em> must match the requirements of the format string. For example, if an integer was passed where a string was expected, an error of some kind will most likely occur.</p>
<p>The caller must ensure that the buffer <em>pcBuf</em> is large enough to hold the entire converted string, including the null termination character.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the count of characters that were written to the output buffer, not including the NULL termination character. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2a7ef5e22c99a2f20a0d0be873c0e806"></a><!-- doxytag: member="ustdlib.c::ustrnicmp" ref="ga2a7ef5e22c99a2f20a0d0be873c0e806" args="(const char *pcStr1, const char *pcStr2, int iCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ustrnicmp </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pcStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pcStr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compares two strings without regard to case.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcStr1</em>&nbsp;</td><td>points to the first string to be compared. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pcStr2</em>&nbsp;</td><td>points to the second string to be compared. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iCount</em>&nbsp;</td><td>is the maximum number of characters to compare.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strnicmp()</code> function. It compares at most <em>iCount</em> characters of two strings without regard to case. The comparison ends if a terminating NULL character is found in either string before <em>iCount</em> characters are compared. In this case, the shorter string is deemed the lesser.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 if the two strings are equal, -1 if <em>pcStr1</em> is less than <em>pcStr2</em> and 1 if <em>pcStr1</em> is greater than <em>pcStr2</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gac2eecc2b64595f203ab61479a7729036"></a><!-- doxytag: member="ustdlib.c::ustrstr" ref="gac2eecc2b64595f203ab61479a7729036" args="(const char *pcHaystack, const char *pcNeedle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ustrstr </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pcHaystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pcNeedle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds a substring within a string.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcHaystack</em>&nbsp;</td><td>is a pointer to the string that will be searched. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pcNeedle</em>&nbsp;</td><td>is a pointer to the substring that is to be found within <em>pcHaystack</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strstr()</code> function. It scans a string for the first instance of a given substring and returns a pointer to that substring. If the substring cannot be found, a NULL pointer is returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a pointer to the first occurrence of <em>pcNeedle</em> within <em>pcHaystack</em> or NULL if no match is found. </dd></dl>

</div>
</div>
<a class="anchor" id="ga22fa13dc554cf317be1f6910e070b359"></a><!-- doxytag: member="ustdlib.c::ustrtoul" ref="ga22fa13dc554cf317be1f6910e070b359" args="(const char *pcStr, const char **ppcStrRet, int iBase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long ustrtoul </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pcStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>ppcStrRet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>iBase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts a string into its numeric equivalent.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcStr</em>&nbsp;</td><td>is a pointer to the string containing the integer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ppcStrRet</em>&nbsp;</td><td>is a pointer that will be set to the first character past the integer in the string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iBase</em>&nbsp;</td><td>is the radix to use for the conversion; can be zero to auto-select the radix or between 2 and 16 to explicitly specify the radix.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strtoul()</code> function. It scans a string for the first token (that is, non-white space) and converts the value at that location in the string into an integer value.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the result of the conversion. </dd></dl>

</div>
</div>
<a class="anchor" id="gad3b713ceeb82516ed0373e7d4343d6e9"></a><!-- doxytag: member="ustdlib.c::uvsnprintf" ref="gad3b713ceeb82516ed0373e7d4343d6e9" args="(char *pcBuf, unsigned long ulSize, const char *pcString, va_list vaArgP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uvsnprintf </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>pcBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>ulSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>vaArgP</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A simple vsnprintf function supporting %c, %d, %p, %s, %u, %x, and %X.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pcBuf</em>&nbsp;</td><td>points to the buffer where the converted string is stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ulSize</em>&nbsp;</td><td>is the size of the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pcString</em>&nbsp;</td><td>is the format string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vaArgP</em>&nbsp;</td><td>is the list of optional arguments, which depend on the contents of the format string.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>vsnprintf()</code> function. Only the following formatting characters are supported:</p>
<ul>
<li>%c to print a character</li>
<li>%d to print a decimal value</li>
<li>%s to print a string</li>
<li>%u to print an unsigned decimal value</li>
<li>%x to print a hexadecimal value using lower case letters</li>
<li>%X to print a hexadecimal value using lower case letters (not upper case letters as would typically be used)</li>
<li>%p to print a pointer as a hexadecimal value</li>
<li>%% to print out a % character</li>
</ul>
<p>For %d, %p, %s, %u, %x, and %X, an optional number may reside between the % and the format character, which specifies the minimum number of characters to use for that value; if preceded by a 0 then the extra characters will be filled with zeros instead of spaces. For example, ``%8d'' will use eight characters to print the decimal value with spaces added to reach eight; ``%08d'' will use eight characters as well but will add zeroes instead of spaces.</p>
<p>The type of the arguments after <em>pcString</em> must match the requirements of the format string. For example, if an integer was passed where a string was expected, an error of some kind will most likely occur.</p>
<p>The <em>ulSize</em> parameter limits the number of characters that will be stored in the buffer pointed to by <em>pcBuf</em> to prevent the possibility of a buffer overflow. The buffer size should be large enough to hold the expected converted output string, including the null termination character.</p>
<p>The function will return the number of characters that would be converted as if there were no limit on the buffer size. Therefore it is possible for the function to return a count that is greater than the specified buffer size. If this happens, it means that the output was truncated.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the number of characters that were to be stored, not including the NULL termination character, regardless of space in the buffer. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Jun 16 10:36:11 2010 for Hardware Abstraction Layer by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
